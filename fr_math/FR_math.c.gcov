        -:    0:Source:src/FR_math.c
        -:    0:Graph:build/FR_math.gcno
        -:    0:Data:build/FR_math.gcda
        -:    0:Runs:6
        -:    1:/**
        -:    2: *
        -:    3: *	@file FR_math.c - c implementation file for basic fixed
        -:    4: *                              radix math routines
        -:    5: *
        -:    6: *	@copy Copyright (C) <2001-2014>  <M. A. Chatterjee>
        -:    7: *  @author M A Chatterjee <deftio [at] deftio [dot] com>
        -:    8: *	@version 1.0.3 M. A. Chatterjee, cleaned up naming
        -:    9: *
        -:   10: *  This file contains integer math settable fixed point radix math routines for
        -:   11: *  use on systems in which floating point is not desired or unavailable.
        -:   12: *
        -:   13: *	This software is provided 'as-is', without any express or implied
        -:   14: *	warranty. In no event will the authors be held liable for any damages
        -:   15: *	arising from the use of this software.
        -:   16: *
        -:   17: *	Permission is granted to anyone to use this software for any purpose,
        -:   18: *	including commercial applications, and to alter it and redistribute it
        -:   19: *	freely, subject to the following restrictions:
        -:   20: *
        -:   21: *	1. The origin of this software must not be misrepresented; you must not
        -:   22: *	claim that you wrote the original software. If you use this software
        -:   23: *	in a product, please place an acknowledgment in the product documentation.
        -:   24: *
        -:   25: *	2. Altered source versions must be plainly marked as such, and must not be
        -:   26: *	misrepresented as being the original software.
        -:   27: *
        -:   28: *	3. This notice may not be removed or altered from any source
        -:   29: *	distribution.
        -:   30: *
        -:   31: */
        -:   32:
        -:   33:#include "FR_math.h"
        -:   34:
        -:   35:/*=======================================================
        -:   36: * FR_FixMuls (x*y signed NOT saturated mul)
        -:   37: * User must keep track of new radix point after using this function
        -:   38: */
        -:   39:
        4:   40:s32 FR_FixMuls(s32 x, s32 y) /* signed not saturated */
        -:   41:{
        4:   42:	s32 z, sign = (x < 0) ? (y > 0) : (y < 0);
        -:   43:
        4:   44:	x = FR_ABS(x);
        4:   45:	y = FR_ABS(y);
        4:   46:	z = FR_FIXMUL32u(x, y);
        -:   47:
        4:   48:	return sign ? -z : z;
        -:   49:}
        -:   50:
        -:   51:/*=======================================================
        -:   52: * FR_FixMulSat (x*y saturated multiply)
        -:   53: * User must keep track of new radix point after using this function
        -:   54: */
        -:   55:
       33:   56:s32 FR_FixMulSat(s32 x, s32 y)
        -:   57:{
        -:   58:	s32 z, h, l, m1, m2;
       33:   59:	int sign = (((x < 0) && (y > 0)) || ((x > 0) && (y < 0))) ? 1 : 0;
        -:   60:
       33:   61:	x = FR_ABS(x);
       33:   62:	y = FR_ABS(y);
       33:   63:	h = ((x >> 16) * (y >> 16));
       33:   64:	m1 = ((x >> 16) * (y & 0xffff));
       33:   65:	m2 = ((y >> 16) * (x & 0xffff));
       33:   66:	l = (((x & 0xffff) * (y & 0xffff)));
        -:   67:
       33:   68:	z = (h << 16) + m1 + m2 + l;
        -:   69:
       33:   70:	if (h & 0xffff8000) /* TODO: make better saturation check -- this might be a bug */
        -:   71:		z = 0x7fffffff;
        -:   72:	else
        -:   73:	{
        -:   74:		z = (h << 16) + m1;
       32:   75:		if (z < 0)
        -:   76:			z = 0x7fffffff;
        -:   77:		else
        -:   78:		{
        -:   79:			z += m2;
       32:   80:			if (z < 0)
        -:   81:				z = 0x7fffffff;
        -:   82:			else
        -:   83:			{
        -:   84:				z += l;
       32:   85:				if (z < 0)
        -:   86:					z = 0x7fffffff;
        -:   87:			}
        -:   88:		}
        -:   89:	}
       33:   90:	return sign ? -z : z;
        -:   91:}
        -:   92:
        -:   93:/*=======================================================
        -:   94:  FR_FixAddSat (x+y saturated add)
        -:   95:  programmer must align radix points before using this function
        -:   96: */
       39:   97:s32 FR_FixAddSat(s32 x, s32 y)
        -:   98:{
       39:   99:	s32 sum = x + y;
       39:  100:	if (x < 0)
        -:  101:	{
        1:  102:		if (y < 0)
        1:  103:			return (sum >= 0) ? 0x80000000 : sum;
        -:  104:	}
        -:  105:	else
        -:  106:	{
       38:  107:		if (y >= 0)
       27:  108:			return (sum <= 0) ? 0x7fffffff : sum;
        -:  109:	}
        -:  110:	return sum;
        -:  111:}
        -:  112:
        -:  113:/* Cosine table in s0.15 format, 1 entry per degree
        -:  114: * used in all trig functions (sin,cos,tan, atan2 etc)
        -:  115: */
        -:  116:s16 const static gFR_COS_TAB_S0d15[] = {
        -:  117:	32767, 32762, 32747, 32722, 32687, 32642, 32587, 32522, 32448, 32363,
        -:  118:	32269, 32164, 32050, 31927, 31793, 31650, 31497, 31335, 31163, 30981,
        -:  119:	30790, 30590, 30381, 30162, 29934, 29696, 29450, 29195, 28931, 28658,
        -:  120:	28377, 28086, 27787, 27480, 27165, 26841, 26509, 26168, 25820, 25464,
        -:  121:	25100, 24729, 24350, 23964, 23570, 23169, 22761, 22347, 21925, 21497,
        -:  122:	21062, 20620, 20173, 19719, 19259, 18794, 18323, 17846, 17363, 16876,
        -:  123:	16383, 15885, 15383, 14875, 14364, 13847, 13327, 12803, 12274, 11742,
        -:  124:	11207, 10668, 10125, 9580, 9032, 8481, 7927, 7371, 6813, 6252,
        -:  125:	5690, 5126, 4560, 3993, 3425, 2856, 2286, 1715, 1144, 572,
        -:  126:	0};
        -:  127:
        -:  128:/* cosine with integer input precision in degrees, returns s0.15 result
        -:  129: */
        -:  130:
      105:  131:s16 FR_CosI(s16 deg)
        -:  132:{
      105:  133:	deg = deg % 360; /* this is an expensive operation*/
      105:  134:	if (deg > 180)
        -:  135:	{
       16:  136:		deg -= 360;
        -:  137:	}
       89:  138:	else if (deg < -180)
        -:  139:	{
        2:  140:		deg += 360;
        -:  141:	}
        -:  142:
      105:  143:	if (deg >= 0)
       66:  144:		return deg <= (90) ? gFR_COS_TAB_S0d15[deg] : -gFR_COS_TAB_S0d15[180 - deg];
        -:  145:	else
       39:  146:		return deg >= (-90) ? gFR_COS_TAB_S0d15[-deg] : -gFR_COS_TAB_S0d15[180 + deg];
        -:  147:}
        -:  148:/* sin with integer input precision in degrees, returns s0.15 result
        -:  149: */
       31:  150:s16 FR_SinI(s16 deg)
        -:  151:{
       31:  152:	return FR_CosI(deg - 90);
        -:  153:}
        -:  154:
        -:  155:/* cos() with fixed radix precision, returns interpolated s0.15 result
        -:  156: */
       13:  157:s16 FR_Cos(s16 deg, u16 radix)
        -:  158:{
        -:  159:	s16 i, j;
       13:  160:	i = FR_CosI(deg >> radix);
       13:  161:	j = FR_CosI((deg >> radix) + 1);
       13:  162:	return i + (((j - i) * (deg & ((1 << radix) - 1))) >> radix);
        -:  163:}
        -:  164:
        -:  165:/* sin() with fixed radix precision,  returns interpolated s0.15 result
        -:  166: * could be a macro..
        -:  167: */
        6:  168:s16 FR_Sin(s16 deg, u16 radix)
        -:  169:{
        6:  170:	return FR_Cos(deg - (90 << radix), radix);
        -:  171:}
        -:  172:
        -:  173:s16 const static gFR_TAND_TAB[] = {
        -:  174:	1, 572, 1144, 1717, 2291, 2867, 3444, 4023, 4605, 5189,
        -:  175:	5777, 6369, 6964, 7564, 8169, 8779, 9395, 10017, 10646, 11282,
        -:  176:	11926, 12578, 13238, 13908, 14588, 15279, 15981, 16695, 17422, 18163,
        -:  177:	18918, 19688, 20475, 21279, 22101, 22943, 23806, 24691, 25600, 26534,
        -:  178:	27494, 28483, 29503, 30555, 31642, 32767};
        -:  179:
        -:  180:/* tan with s15.16 result
        -:  181: * tan without table.
        -:  182: * note: tan(90)  returns   32767
        -:  183: * and   tan(270) returns (-32768) (e.g. no div by zero)
        -:  184: */
        -:  185:/*
        -:  186:s32 FR_TanI (s16 deg)
        -:  187:{
        -:  188:	s32 c = FR_CosI(deg);
        -:  189:	s32 s = FR_SinI(deg);
        -:  190:	return (c!=0)?(s<<FR_TRIG_PREC)/c : (s>=0)?(FR_TRIG_MAXVAL<<FR_TRIG_PREC):(FR_TRIG_MINVAL<<FR_TRIG_PREC);
        -:  191:}
        -:  192:*/
        -:  193:#define FR_TN(a) (((a) <= 45) ? gFR_TAND_TAB[(a)] : (FR_TRIG_MAXVAL << FR_TRIG_PREC) / (gFR_TAND_TAB[90 - (a)]))
       17:  194:s32 FR_TanI(s16 deg)
        -:  195:{
       17:  196:	deg = deg % 360; /* this is an expensive operation */
       17:  197:	if (deg > 180)
        -:  198:	{
        2:  199:		deg -= 360;
        -:  200:	}
       15:  201:	else if (deg < -180)
        -:  202:	{
        1:  203:		deg += 360;
        -:  204:	}
        -:  205:
       17:  206:	if (90 == deg)
        -:  207:		return (FR_TRIG_MAXVAL << FR_TRIG_PREC);
        -:  208:	if (270 == deg)
        -:  209:		return -(FR_TRIG_MAXVAL << FR_TRIG_PREC);
        -:  210:
       16:  211:	if (deg >= 0)
      12*:  212:		return deg <= (90) ? FR_TN(deg) : -FR_TN(180 - deg);
        -:  213:	else
       4*:  214:		return deg >= (-90) ? -FR_TN(-deg) : FR_TN(180 + deg);
        -:  215:}
        -:  216:/* Tan with s15.16 result with fixed radix input precision, returns interpolated s15.16 result
        -:  217: */
        -:  218:
        2:  219:s32 FR_Tan(s16 deg, u16 radix)
        -:  220:{
        -:  221:	s16 i, j;
        2:  222:	i = FR_TanI(deg >> radix);
        2:  223:	j = FR_TanI((deg >> radix) + 1);
        2:  224:	return FR_INTERPI(i, j, deg, radix); /*i+(((j-i)*(deg&((1<<radix)-1)))>>radix);*/
        -:  225:}
        -:  226:
        -:  227:/* Inverse Trig
        -:  228: * Ugly looking acos with bin search (working):
        -:  229: */
        7:  230:s16 FR_acos(s32 input, u16 radix)
        -:  231:{
        7:  232:	s16 r = 45, s = input, x = 46, y, z;
        -:  233:
       7*:  234:	input = FR_CHRDX(input, radix, FR_TRIG_PREC); /* chg radix to s0.15 */
        -:  235:
        -:  236:	// +or- 1.0000 is special case as it doesn't fit in table search
        7:  237:	if ((input & 0xffff) == 0x8000) //? shouldn't it be: (input&7fff)!=0
        5:  238:		return (input < 0) ? 180 : 0;
        2:  239:	input = (FR_ABS(input)) & ((1 << radix) - 1);
       12:  240:	while (x >>= 1)
      10*:  241:		r += (input < gFR_COS_TAB_S0d15[r]) ? x : -x;
        -:  242:
        2:  243:	r += (input < gFR_COS_TAB_S0d15[r]) ? 1 : -1;
        2:  244:	r += (input < gFR_COS_TAB_S0d15[r]) ? 1 : -1;
        -:  245:
        2:  246:	x = FR_ABS(input - gFR_COS_TAB_S0d15[r]);
        2:  247:	y = FR_ABS(input - gFR_COS_TAB_S0d15[r + 1]);
        2:  248:	z = FR_ABS(input - gFR_COS_TAB_S0d15[r - 1]);
        2:  249:	r = (x < y) ? r : r + 1;
       2*:  250:	r = (x < z) ? r : r - 1;
        -:  251:
        2:  252:	return (s > 0) ? r : 180 - r;
        -:  253:	;
        -:  254:}
        -:  255:
        2:  256:s16 FR_asin(s32 input, u16 radix)
        -:  257:{
        2:  258:	return 90 - FR_acos(input, radix);
        -:  259:}
    #####:  260:s16 FR_atan2(s32 y, s32 x, u16 radix)
        -:  261:{
        -:  262:	int q;
    #####:  263:	if (0 == x)
    #####:  264:		return y < 0 ? FR_TRIG_MINVAL : FR_TRIG_MAXVAL;
        -:  265:
    #####:  266:	q = (y >= 0) ? ((x >= 0) ? 0 : 1) : ((x >= 0) ? 3 : 2);
    #####:  267:	return q;
        -:  268:}
        -:  269:
        -:  270:/* Raise x to the xth power
        -:  271: */
        -:  272:
        -:  273:#define FR_kPOW2COEF_PREC (4)
        -:  274:u16 static const gPOW2_ICOEF[17] = {
        -:  275:	0, 2902, 5932, 9096, 12400, 15850, 19454, 23216, 27146,
        -:  276:	31249, 35534, 40009, 44682, 49562, 54658, 59979, 65535}; /* 16bit prec */
        -:  277:
        -:  278:/* Accuracy vs space tradeoff:
        -:  279: * can save some space by comment out above coef and using smaller table here.
        -:  280: *
        -:  281:#define FR_kPOW2COEF_PREC	(3)
        -:  282:u16 static const gPOW2_ICOEF[9] = {0,5932,12400,19454,27146,35534,44682,54658,65535}; // 16bit prec
        -:  283: */
        -:  284:
        -:  285:// TODO: keep prec up... should be input# of bits + 14 (includes interp error etc..)
        -:  286://  pow2: 383 bytes of 32bit x86 code under gcc cygwin with tables counted (and before output radix stuff added)
        -:  287:// e.g. outputradix = input+14 bits of prec so
        -:  288://  if input > 30 output = MAXINTu32
        -:  289://  if input+14 < 20 output radix = 30-input
        -:  290://  if input+14 < 16 ouptut radix = 16 (e.g. don't just slam the radix point way to the left we don't have that precision anyway.
       15:  291:s32 FR_pow2(s32 input, u16 radix)
        -:  292:{
        -:  293:	s32 flr, frac, k, j, sc;
       15:  294:	flr = FR_INT(input, radix);
      15*:  295:	frac = FR_FRACS(input, radix, FR_kPOW2COEF_PREC);
       15:  296:	k = (s32)(gPOW2_ICOEF[frac]);
       15:  297:	j = (s32)(gPOW2_ICOEF[frac + 1]);
       15:  298:	sc = ((j - k) >> 8) + ((j - k) >> 10) + ((j - k) >> 11); /* slope correction */
      15*:  299:	frac = ((FR_FRACS(input, radix, 15)) - (FR_FRACS(frac, FR_kPOW2COEF_PREC, 15))) << FR_kPOW2COEF_PREC;
       15:  300:	if (frac <= (1 << (15 - 1)))
       15:  301:		sc = FR_INTERP(0, sc, frac, 14);
        -:  302:	else
    #####:  303:		sc = FR_INTERP(sc, 0, frac - (1 << (15 - 1)), 14);
        -:  304:
       15:  305:	k = FR_INTERP(k, j, frac, 15) - sc;
        -:  306:
       15:  307:	if (flr >= 0) /* positive powers of 2 */
        -:  308:	{
      10*:  309:		k = FR_CHRDX((k << flr), 16, radix);
       10:  310:		j = (1 << flr) << radix;
        -:  311:	}
        -:  312:	else /* negative powers of 2 */
        -:  313:	{
        5:  314:		flr = -flr;
       5*:  315:		k = FR_CHRDX((k >> flr), 16, radix);
        5:  316:		j = (radix - flr) >= 0 ? 1 << (radix - flr) : 0;
        -:  317:	}
       15:  318:	return j + k;
        -:  319:}
        -:  320:/*
        -:  321:s32 FR_exp(s32 input, u16 radix)
        -:  322:{
        -:  323:	return FR_pow2(FR_SLOG2E(input),radix);
        -:  324:}
        -:  325:
        -:  326:s32 FR_pow10(s32 input, u16 radix)
        -:  327:{
        -:  328:	if (FR_FRAC(input,radix))
        -:  329:		return FR_pow2(FR_SLOG2_10(input),radix);
        -:  330:	else
        -:  331:	{
        -:  332:		input = FR_INT(input,radix);
        -:  333:		if (input >=0)
        -:  334:		{
        -:  335:			s32 x=10;
        -:  336:			while (input--)
        -:  337:				x = FR_SMUL10(x);
        -:  338:			return x<<radix;
        -:  339:		}
        -:  340:		return FR_pow2(FR_SLOG2_10(input),radix);
        -:  341:	}
        -:  342:}
        -:  343:*/
        -:  344:
        -:  345:/*log2 returns FR_LOG2MIN if input <= 0 */
       26:  346:s32 FR_log2(s32 input, u16 radix, u16 output_radix)
        -:  347:{
        -:  348:	s32 h = 16; //,frac = FR_FRAC(input,radix);
      130:  349:	while (h >>= 1)
        -:  350:	{
      104:  351:		if (input > (1 << h))
        -:  352:		{
       50:  353:			input >>= h;
        -:  354:		} // i+=h; input>>=h
        -:  355:	}
        -:  356:
      26*:  357:	return input <= 0 ? FR_LOG2MIN : FR_CHRDX(input, radix, output_radix);
        -:  358:}
        -:  359:
        3:  360:s32 FR_ln(s32 input, u16 radix, u16 output_radix)
        -:  361:{
        3:  362:	s32 r = FR_log2(input, radix, output_radix);
        3:  363:	return FR_SrLOG2E(r); /* Note: return FR_SrLOG2E(FR_log2()) would be a very ugly macro expansion! */
        -:  364:}
        -:  365:
        4:  366:s32 FR_log10(s32 input, u16 radix, u16 output_radix)
        -:  367:{
        4:  368:	s32 r = FR_log2(input, radix, output_radix);
        4:  369:	return FR_SrLOG2_10(r); /* Note: return FR_SrLOG2_10(FR_log2()) would be a very ugly macro expansion! */
        -:  370:}
        -:  371:
        -:  372:/***************************************
        -:  373: FR_printNum write out fixed radix number with space padding
        -:  374:  equiavlent ot %f in printf family
        -:  375:  myNum = 12.34 // in fixed num
        -:  376:  e.g. printf("%4.2f",myNum ) ==> "  12"
        -:  377:
        -:  378:
        -:  379:	printf("test fr math rad \n");
        -:  380:
        -:  381:	FR_printNumF (putchar,  123456   , 0, 3, 0);    printf("\n");
        -:  382:	FR_printNumF (putchar,  123456<<13 , 13, 3, 4);    printf(":\n");
        -:  383:	FR_printNumF (putchar,  D2FR(1234.5678,13)   , 13, 3, 6);    printf(":\n");
        -:  384:	FR_printNumF (putchar,  D2FR(-1234.5678,13)   , 13, 3, 6);    printf(":\n");
        -:  385: */
        -:  386:
    #####:  387:int FR_printNumF(int (*f)(char), s32 n, int radix, int pad, int prec)
        -:  388:{
    #####:  389:	int t = 10, s = 0, r = FR_FRAC(n, radix);
    #####:  390:	n = FR_INT(n, radix);
    #####:  391:	if (f)
        -:  392:	{
    #####:  393:		if (n < 0)
        -:  394:		{
    #####:  395:			n = -n, s = 1;
    #####:  396:			pad--;
        -:  397:		}
    #####:  398:		while ((n / t) > 0)
        -:  399:		{
    #####:  400:			t *= 10;
    #####:  401:			pad--;
        -:  402:		}
    #####:  403:		while (pad-- > 0)
        -:  404:		{
    #####:  405:			f(' ');
        -:  406:		}
    #####:  407:		if (s)
    #####:  408:			f('-');
    #####:  409:		while (t >= 10)
        -:  410:		{
    #####:  411:			t /= 10;
    #####:  412:			f((char)((n / t) % 10) + '0');
        -:  413:		}
    #####:  414:		if (prec || r)
        -:  415:		{
    #####:  416:			f('.');
        -:  417:			s = 1 << (radix);
    #####:  418:			if (r)
        -:  419:			{
    #####:  420:				while (s)
        -:  421:				{
    #####:  422:					r *= 10;
    #####:  423:					s /= 10;
        -:  424:				}
        -:  425:			}
    #####:  426:			r >>= radix;
        -:  427:			// r++;
        -:  428:			t = 1;
    #####:  429:			while ((r / t) > 0)
        -:  430:			{
    #####:  431:				t *= 10;
        -:  432:			}
    #####:  433:			while ((t >= 10) && (prec))
        -:  434:			{
    #####:  435:				t /= 10;
    #####:  436:				prec--;
    #####:  437:				f((char)((r / t) % 10) + '0');
        -:  438:			}
    #####:  439:			while (prec-- > 0)
        -:  440:			{
    #####:  441:				f('0');
        -:  442:			}
        -:  443:		}
    #####:  444:		return 0;
        -:  445:	}
        -:  446:	return -1;
        -:  447:}
        -:  448:/***************************************
        -:  449: FR_printNumD write out a decimal integer with space padding
        -:  450:  equiavlent ot %d in printf family
        -:  451:  int num = 12
        -:  452:  e.g. printf("%4d",num) ==> "  12"
        -:  453:
        -:  454: */
    #####:  455:int FR_printNumD(int (*f)(char), int n, int pad)
        -:  456:{
        -:  457:	int t = 10, s = 0;
    #####:  458:	if (f)
        -:  459:	{
    #####:  460:		if (n < 0)
        -:  461:		{
    #####:  462:			n = -n, s = 1;
    #####:  463:			pad--;
        -:  464:		}
    #####:  465:		while ((n / t) > 0)
        -:  466:		{
    #####:  467:			t *= 10;
    #####:  468:			pad--;
        -:  469:		}
    #####:  470:		while (pad-- > 0)
        -:  471:		{
    #####:  472:			f(' ');
        -:  473:		}
    #####:  474:		if (s)
    #####:  475:			f('-');
    #####:  476:		while (t >= 10)
        -:  477:		{
    #####:  478:			t /= 10;
    #####:  479:			f((char)((n / t) % 10) + '0');
        -:  480:		}
        -:  481:		return FR_S_OK;
        -:  482:	}
        -:  483:	return FR_E_FAIL;
        -:  484:}
        -:  485:/***************************************
        -:  486: FR_printNumH write out a integer as hex
        -:  487: if (showPrefix == true )
        -:  488:	print "0x"
        -:  489: else
        -:  490:	//no prefix printed
        -:  491: */
        -:  492:
    #####:  493:int FR_printNumH(int (*f)(char), int n, int showPrefix)
        -:  494:{
        -:  495:	int d, x = ((sizeof(int)) << 1) - 1;
    #####:  496:	if (f)
        -:  497:	{
    #####:  498:		if (showPrefix)
        -:  499:		{
    #####:  500:			f('0');
    #####:  501:			f('x');
        -:  502:		}
        -:  503:
        -:  504:		do
        -:  505:		{
    #####:  506:			d = (n >> (x << 2)) & 0xf;
    #####:  507:			d = (d > 9) ? (d - 0xa + 'a') : (d + '0');
    #####:  508:			f(d);
    #####:  509:		} while (x--);
        -:  510:		return FR_S_OK;
        -:  511:	}
        -:  512:	return FR_E_FAIL;
        -:  513:}
